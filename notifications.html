<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Notifications - Ripple</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&family=Courgette&display=swap" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="main.css">
  <link rel="stylesheet" href="notifications.css">
</head>
<body>
  <div id="header-placeholder"></div>

  <main class="notif-page">
    <div class="notif-shell">
      <h1>Notifications</h1>
      <p class="small-muted">Moderation results, event signups, saved resources, and role request updates appear here.</p>
      <div id="notifList"></div>
    </div>
  </main>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
    import { getFirestore, collection, onSnapshot, doc, getDoc, updateDoc, addDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    const firebaseConfig = {
      apiKey: "AIzaSyBguT9BsQHwsAwAd3mbEmj3S5E7GtR_IBU",
      authDomain: "webmaster-v4-0.firebaseapp.com",
      projectId: "webmaster-v4-0",
      storageBucket: "webmaster-v4-0.firebasestorage.app",
      messagingSenderId: "413556961992",
      appId: "1:413556961992:web:899600895ecb68eb9debfd"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    window.__notifModuleLoaded = true;
    const notifList = document.getElementById('notifList');
    let activeUnsubs = [];
    let currentUserRole = 'member';
    let activeUser = null;
    function clearListeners() {
      activeUnsubs.forEach((unsub) => {
        try { unsub(); } catch (_) {}
      });
      activeUnsubs = [];
    }
    function getVisitorId() {
      const key = 'rippleVisitorId';
      let id = localStorage.getItem(key);
      if (!id) {
        id = `visitor_${Math.random().toString(36).slice(2, 10)}_${Date.now().toString(36)}`;
        localStorage.setItem(key, id);
      }
      return id;
    }
    async function getPublicIp() {
      const cached = localStorage.getItem('ripplePublicIp');
      if (cached) return cached;
      try {
        const resp = await fetch('https://api.ipify.org?format=json', { cache: 'no-store' });
        const data = await resp.json();
        const ip = data && data.ip ? data.ip : '';
        if (ip) {
          localStorage.setItem('ripplePublicIp', ip);
          return ip;
        }
      } catch (err) {
        console.warn('IP fetch failed:', err.message);
      }
      return '';
    }
    async function resolveParticipantIdentity(user) {
      if (user) {
        const identity = {
          participantId: `uid:${user.uid}`,
          participantType: 'account',
          uid: user.uid,
          createdBy: user.uid,
          createdByEmail: user.email || null,
          ip: null
        };
        await setDoc(doc(db, 'participantIdentities', identity.participantId), {
          ...identity,
          updatedAt: serverTimestamp()
        }, { merge: true });
        return identity;
      }
      const visitorId = getVisitorId();
      const ip = await getPublicIp();
      const participantId = ip ? `ip:${ip}` : `visitor:${visitorId}`;
      const identity = {
        participantId,
        participantType: ip ? 'ip' : 'visitor',
        uid: null,
        createdBy: visitorId,
        createdByEmail: null,
        ip: ip || null
      };
      await setDoc(doc(db, 'participantIdentities', identity.participantId), {
        ...identity,
        updatedAt: serverTimestamp()
      }, { merge: true });
      return identity;
    }
    function isAdminRole(role) {
      const normalized = (role || '').toLowerCase();
      return normalized === 'admin' || normalized === 'founder';
    }
    function isRoleRequestForModeration(data) {
      if (data.type !== 'roleRequest') return false;
      const status = (data.status || '').toLowerCase();
      if (!(status === 'unread' || status === 'pending')) return false;
      if (Array.isArray(data.recipientsRole) && data.recipientsRole.length) {
        return data.recipientsRole.some(r => ['admin', 'founder'].includes((r || '').toLowerCase()));
      }
      return true;
    }
    function isAdminRecipientNotification(data) {
      if (!Array.isArray(data.recipientsRole) || !data.recipientsRole.length) return false;
      return data.recipientsRole.some(r => ['admin', 'founder'].includes((r || '').toLowerCase()));
    }
    function formatTimestamp(raw) {
      if (!raw) return '';
      try {
        const date = typeof raw.toDate === 'function' ? raw.toDate() : new Date(raw);
        if (isNaN(date)) return '';
        return date.toLocaleString();
      } catch (_) {
        return '';
      }
    }
    function buildMeta(data) {
      const bits = [];
      if (data.itemType) bits.push(data.itemType);
      if (data.status) bits.push(`status: ${data.status}`);
      if (data.createdByEmail) bits.push(`by ${data.createdByEmail}`);
      const when = formatTimestamp(data.createdAt);
      if (when) bits.push(when);
      return bits.join(' â€¢ ') || 'Notification';
    }
    function shouldShowPersonalNotification(data, identity, user) {
      const participantMatch = data.participantId && data.participantId === identity.participantId;
      const createdByMatch = data.createdBy && data.createdBy === identity.createdBy;
      const emailMatch = !!(user && data.createdByEmail && user.email && data.createdByEmail === user.email);
      const recipientMatch = data.recipientParticipantId && data.recipientParticipantId === identity.participantId;
      if (isAdminRecipientNotification(data)) {
        return participantMatch || recipientMatch;
      }
      return participantMatch || createdByMatch || emailMatch || recipientMatch;
    }
    async function handleRoleRequestDecision(notificationId, data, decision) {
      if (!activeUser || !isAdminRole(currentUserRole)) return;
      const approved = decision === 'approved';
      const reqRef = doc(db, 'roleRequests', data.itemId);
      const reqSnap = await getDoc(reqRef);
      if (!reqSnap.exists()) throw new Error('Role request not found');
      const reqData = reqSnap.data();
      const requestorId = reqData.createdBy || data.requestorId || reqData.requestorId || null;
      const requestorEmail = reqData.createdByEmail || data.createdByEmail || null;
      if (approved && requestorId && !String(requestorId).startsWith('visitor_')) {
        await setDoc(doc(db, 'users', requestorId), { role: 'admin' }, { merge: true });
      }
      await updateDoc(reqRef, {
        status: approved ? 'approved' : 'denied',
        moderatedBy: activeUser.uid,
        moderatedAt: serverTimestamp()
      });
      await updateDoc(doc(db, 'notifications', notificationId), {
        status: 'handled',
        result: approved ? 'approved' : 'denied',
        handledBy: activeUser.uid,
        handledAt: serverTimestamp()
      });
      if (requestorId) {
        const recipientParticipantId = String(requestorId).startsWith('visitor_') ? `visitor:${requestorId}` : `uid:${requestorId}`;
        await addDoc(collection(db, 'notifications'), {
          type: 'roleRequestResult',
          itemType: 'roleRequest',
          itemId: data.itemId,
          title: approved ? 'Admin Request Approved' : 'Admin Request Denied',
          message: approved
            ? 'Your admin role request was approved.'
            : 'Your admin role request was denied.',
          status: 'unread',
          createdBy: requestorId,
          createdByEmail: requestorEmail,
          participantId: recipientParticipantId,
          recipientParticipantId,
          moderatedBy: activeUser.uid,
          moderatedByEmail: activeUser.email || null,
          createdAt: serverTimestamp()
        });
      }
    }
    function renderNotifications(list, identity, isAdmin) {
      notifList.innerHTML = '';
      if (!list.length) {
        notifList.innerHTML = '<div class="notif-empty">No notifications yet.</div>';
        return;
      }
      list
        .slice()
        .sort((a, b) => {
          const at = a.data.createdAt && typeof a.data.createdAt.toMillis === 'function' ? a.data.createdAt.toMillis() : 0;
          const bt = b.data.createdAt && typeof b.data.createdAt.toMillis === 'function' ? b.data.createdAt.toMillis() : 0;
          return bt - at;
        })
        .forEach(({ id, data }) => {
          const card = document.createElement('div');
          card.className = 'notif-card';
          const left = document.createElement('div');
          left.className = 'notif-left';
          const title = document.createElement('div');
          title.className = 'notif-title';
          title.textContent = data.title || data.message || 'Notification';
          const meta = document.createElement('div');
          meta.className = 'notif-meta';
          meta.textContent = buildMeta(data);
          left.appendChild(title);
          left.appendChild(meta);
          const actions = document.createElement('div');
          actions.className = 'notif-actions';
          if (isAdmin && isRoleRequestForModeration(data)) {
            const approve = document.createElement('button');
            approve.className = 'approve-btn';
            approve.type = 'button';
            approve.textContent = 'Approve';
            approve.addEventListener('click', async () => {
              try {
                await handleRoleRequestDecision(id, data, 'approved');
              } catch (err) {
                console.error(err);
                alert('Failed to approve role request: ' + err.message);
              }
            });
            const deny = document.createElement('button');
            deny.className = 'deny-btn';
            deny.type = 'button';
            deny.textContent = 'Deny';
            deny.addEventListener('click', async () => {
              try {
                await handleRoleRequestDecision(id, data, 'denied');
              } catch (err) {
                console.error(err);
                alert('Failed to deny role request: ' + err.message);
              }
            });
            actions.appendChild(approve);
            actions.appendChild(deny);
          } else {
            const info = document.createElement('div');
            info.textContent = data.message || '';
            actions.appendChild(info);
          }
          card.appendChild(left);
          card.appendChild(actions);
          notifList.appendChild(card);
        });
    }
    function attachSharedNotifications(isAdmin) {
      const unsub = onSnapshot(collection(db, 'notifications'), (snapshot) => {
        const list = [];
        snapshot.forEach((docSnap) => {
          list.push({ id: docSnap.id, data: docSnap.data() });
        });
        renderNotifications(list, { participantId: 'global' }, isAdmin);
      }, (err) => {
        console.error('Notifications listener error:', err);
        notifList.innerHTML = `<div class="notif-empty">Unable to load notifications: ${err.message}</div>`;
      });
      activeUnsubs.push(unsub);
    }
    onAuthStateChanged(auth, async (user) => {
      clearListeners();
      activeUser = user || null;
      const avatar = document.querySelector('.avatar');
      const navRight = document.querySelector('.nav-right');
      if (user) {
        if (avatar) {
          const initial = (user.email || '').charAt(0).toUpperCase();
          if (user.photoURL) {
            avatar.style.backgroundImage = `url('${user.photoURL}')`;
            avatar.style.backgroundSize = 'cover';
            avatar.style.backgroundPosition = 'center';
            avatar.textContent = '';
          } else {
            avatar.style.backgroundImage = '';
            avatar.textContent = initial;
          }
          avatar.style.cursor = 'pointer';
          avatar.onclick = () => window.location.href = 'account.html';
        }
        const signInBtn = document.querySelector('.sign-in-btn');
        if (signInBtn) signInBtn.remove();
        const roleDoc = await getDoc(doc(db, 'users', user.uid));
        currentUserRole = roleDoc.exists() && roleDoc.data().role ? roleDoc.data().role : 'member';
      } else {
        currentUserRole = 'member';
        if (avatar) {
          avatar.textContent = '';
          avatar.style.backgroundImage = '';
          avatar.onclick = () => window.location.href = 'login.html';
        }
        const signOutBtn = document.querySelector('.sign-out-btn');
        if (signOutBtn) signOutBtn.remove();
        if (navRight && !document.querySelector('.sign-in-btn')) {
          const signInBtn = document.createElement('button');
          signInBtn.textContent = 'Sign In';
          signInBtn.className = 'sign-in-btn';
          signInBtn.style.padding = '8px 16px';
          signInBtn.style.background = 'linear-gradient(to bottom, #4c7dff, #2e63e5)';
          signInBtn.style.color = 'white';
          signInBtn.style.border = 'none';
          signInBtn.style.borderRadius = '999px';
          signInBtn.style.cursor = 'pointer';
          signInBtn.style.fontSize = '14px';
          signInBtn.style.fontWeight = '600';
          signInBtn.style.boxShadow = '0 4px 12px rgba(76, 125, 255, 0.25)';
          signInBtn.onclick = () => window.location.href = 'login.html';
          navRight.appendChild(signInBtn);
        }
      }
      const isAdmin = isAdminRole(currentUserRole);
      attachSharedNotifications(isAdmin);
    });
    window.signOutUser = function() {
      signOut(auth).then(() => {
        location.reload();
      }).catch((error) => {
        console.error('Sign out error:', error);
      });
    };
  </script>
 <script>
  document.addEventListener('DOMContentLoaded', function () {
    const headerPlaceholder = document.getElementById('header-placeholder');
    if (!headerPlaceholder) return;

    fetch('header.html')
      .then(response => response.text())
      .then(html => {
        headerPlaceholder.innerHTML = html;

        const path = window.location.pathname.split('/').pop();
        const links = headerPlaceholder.querySelectorAll('.nav-link');
        links.forEach(link => {
          const href = link.getAttribute('href');
          if (href === path) {
            link.classList.add('active');
          } else {
            link.classList.remove('active');
          }
        });
        const hamburger = headerPlaceholder.querySelector('.hamburger');
        const navLinks = headerPlaceholder.querySelector('.nav-links');

        if (hamburger && navLinks) {
          hamburger.addEventListener('click', function (event) {
            event.stopPropagation();
            navLinks.classList.toggle('open');
          });

          document.addEventListener('click', function (event) {
            if (!navLinks.contains(event.target) && !hamburger.contains(event.target)) {
              navLinks.classList.remove('open');
            }
          });
          const navLinkElements = headerPlaceholder.querySelectorAll('.nav-link');
          navLinkElements.forEach(link => {
            link.addEventListener('click', function () {
              navLinks.classList.remove('open');
            });
          });
        }
      })
      .catch(error => {
        console.error('Error loading header:', error);
      });
  });
</script>
<script src="bubble-transition.js"></script>
</body>
</html>
